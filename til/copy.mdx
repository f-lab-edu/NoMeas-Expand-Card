# 복사

원본과 값은 똑같으나, 서로 다른 독립된 대상

```js
let a = 1
let b = a
```

a 식별자에 1이라는 값을 할당하고, b 식별자에는 a값을 할당했다.
= b 식별자는 a의 값을 복사했다.

```js
let a = 1
let b = a
b = 3
console.log(`a의 값은 ${a}, b의 값은 ${b}`) // a의 값은 1, b의 값은 3
```

b에 3이라는 값을 재할당 후 a와 b를 확인해보면 서로 영향을 주지 않았다는 것을 확인할 수 있다.

'복사'의 정의처럼 b 식별자 선언 시 원본과 값은 동일했으나,  
b 식별자에 재할당 후 a는 b의 재할당에 영향을 받지 않았다.

반면 참조값은 다른 결과를 보여준다.

```js
let obj = {
  a: 1
}
let obj2 = obj
```

obj 식별자에 `{a:1}` 객체를 할당한 후, obj2에 obj를 할당한다.
= obj2 식별자는 obj의 값을 복사했다.

```js
let obj = {
  a: 1
}
let obj2 = obj

obj2.a = 3
console.log(`obj 객체의 a 값은 ${obj.a}, obj2 객체의 a 값은 ${obj2.a}`) // obj 객체의 a 값은 3, obj2 객체의 b 값은 3
```

obj2 식별자에 저장된 a를 3으로 재할당 후 obj의 a와 obj2 a를 비교해보면  
obj2의 a 재할당이 obj의 a에 영향을 주었다는 것을 확인할 수 있다.  
'복사'의 정의와 다르게 동작한다.

obj 식별자에 {a:1} 객체를 할당한 후, obj2에 obj를 할당한다.  
= obj2 식별자는 obj의 객체 참조값을 복사했다.

우리는 원시값과 참조값 모두 '복사'라는 말을 사용하지만 실제로 다르게 동작하는 것을 확인할 수 있다.  
복사된 주체(원시 -> 값, 참조 -> 객체 참조값)가 다르다.  
참조값의 복사가 동작하는 방식은 '복사'가 아닌 '공유'가 되었다는 것을 '복사'라는 개념으로 이해하기 어렵다.

# 결론

자바스크립트에서 대입 연산은 항상 '값을 전달'한다.
다만 그 값의 성질이 다를 뿐이다.

- 원시값의 경우, 전달되는 값이 데이터 자체이기 때문에
  자연어적 의미의 '복사'와 동일하게 동작한다.

- 참조값의 경우, 전달되는 값이 객체를 가리키는 참조값이기 때문에
  결과적으로 동일한 객체를 공유하게 된다.

따라서 객체 대입을 '복사'라고 표현하는 것은
자연어적 의미에서는 부정확하며,
정확히는 '참조 공유'에 가깝다.
